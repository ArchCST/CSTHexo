#+OPTIONS: toc:nil \n:t
title: 原码、反码、补码、负数、位运算
date: 2018-09-21
updated:
comments: true
tags:
  - learn
layout: post
------
一些位运算符的基本使用，设计到内存中的数据结构，什么是原码、反码、补码，计算机如何表示负数，
* 机器数
[[https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html][原码, 反码, 补码 详解 - ziqiu.zhang - 博客园]]
原码、反码和补码的设计是为了将符号位也加入 [[https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF][门电路]] 计算。

机器数中，八位二进制数只有后七位为真值的绝对值，第一位是正负符号。例如：
#+BEGIN_SRC 
0000 0001 = +1
1000 0001 = -1
0111 1111 = 127
1111 1111 = -127
#+END_SRC

所以一个八位二进制数的取值范围是 ~+127 ~ -127~，而并非 ~+255 ~ -255~

正数的 =反码= 和原码相同
负数的 =反码= 符号位不变其余的按位取反

正数的 =补码= 和原码也相同
负数的 =补码= 则是其反码+1

另外，补码的特性，=补码= 的 =补码= 就是 =原码=

例如：
| 真值 | 原码      | 反码      | 补码      | 补码的反码 | 补码的补码 |
|   +1 | 0000 0001 | 0000 0001 | 0000 0001 | 0000 0001  | 0000 0001  |
|   +7 | 0000 0111 | 0000 0111 | 0000 0001 | 0000 0111  | 0000 0111  |
|   -1 | 1000 0001 | 1111 1110 | 1111 1111 | 1000 0000  | 1000 0001  |
|   -7 | 1000 1000 | 1111 0111 | 1111 1000 | 1000 0111  | 1000 1000  |

所以对于一个数，计算机都有三种编码方式，其中原码是人可以直接看懂的，而反码和补码（特别是负数的反码和补码）则是需要转换才能看懂的，是专门用来解决门电路设计问题的。

* 减法计算
如果用 ~原码~ 计算 1 - 1，也就是 1 + -1：
#+BEGIN_SRC 
真值      1     +    -1
原码  0000 0001 + 1000 0001 = 1000 0010
真值                                    = -2
#+END_SRC

明显计算是不成立的，而用 ~反码~ 计算：

#+BEGIN_SRC 
真值      1     +    -1
原码  0000 0001 + 1000 0001
反码  0000 0001 + 1111 1110 = 1111 1111
原码                          1000 0000
真值                                    = -0
#+END_SRC

-0 和 0 似乎一样含义，但对机器来说并不合理，并且同时会出现 ~1000 0000~ 和 ~0000 0000~ 两个源码编码表示 0，所以有了补码：

#+BEGIN_SRC 
真值     1     +    -1
原码 0000 0001 + 1000 0001
补码 0000 0001 + 1111 1111 = 1 0000 0000 ;; 这里多出的一位为溢出位，舍弃
原码                           0000 0000
真值                                     = 0
#+END_SRC       

所以计算机中都是用补码进行计算的，内存中也都是存放着补码。

* 位运算
python 中有以下几种位运算：
#+BEGIN_SRC 
&    位与 （按位相乘）
|    位或 （有1为1） （按位相加） 
~    取反
^    异或 （相异为1）
<<   左移
>>   右移
#+END_SRC
** 位与 &
按位相乘，例如求偶数：
#+BEGIN_SRC python
  for i in range (100):
    if i & 1:
      continue
    print(i)
#+END_SRC
用 ~i~ 和 ~0b1~ 做 ~位与~ 运算，既按位相乘，当 i 为 7 的时候：
0000 0111 & 0000 0001 = 0000 0001 = 真，所以 continue
当 i 为 8 的时候：
0000 1000 & 0000 0001 = 0000 0000 = 假，所以 print(i)
可知前面所有位和 1 做位与运算时都为 0（因为 1 的二进制形式为 0b1 也就是 0000 0001）。上述代码简单来说就是一个判断一个数的二进制形式末尾是否为1的判断式。
** 位或 |
** 取反 ~
真值             12
原码          0000 1100
按位取反      1111 0011 ;; 此时为内存中的值，需转原码，由补码的补码既是原码：
补码反码      1000 1100
补码补码      1000 1101
真值             -13

真值            -127
原码          1111 1111
按位取反      0000 0000 ;; 此时为内存中的值，需转原码，由补码的补码既是原码：
补码的反码    0111 1111
补码的补码    0111 1110
真值             126

** 异或 ^
真值     10     ^     9
原码  0000 1010 ^ 0000 1001
补码  0000 1010 ^ 0000 1001
异或                        = 0000 0011
原码                          0000 0011
真值                              3

真值     10     ^    -9
原码  0000 1010 ^ 1000 1001
补码  0000 1010 ^ 1111 0111
异或                        = 1111 1101
原码                          1000 0011
真值                             -3
** 左移和右移 << >>
